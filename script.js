(() => {
  const gameData = {
  "elements": [
    {
      "id": "tahame_taastada",
      "title": "Tahame soo taastada",
      "subtitle": "Oleme veendunud, et kodulähedane soo tuleks taastada",
      "info": "<p>Enne, kui turbaalal saab teha taastamistöid soo taastumiseks, on vaja uurida, planeerida, rääkida ja arutada, et tegemistest soos oleks võimalikult palju kasu ja võimalikult vähe tüli.</p><p>Osa inimesi on ilmselt taastamistööde mõtte poolt, osad on vastu ja osadel on ükskõik. Nõnda on taastamisel vaja arvestada nii kirjutatud kui ka kirjutamata reeglitega.</p><p>Kui olete külaelanikega otsustanud soo taastamismõtetega edasi liikuda, tuleks luua näiteks mittetulundusühing või pöörduda mõne teise sobiva ühingu poole, kes saaks teid aidata või esindada.</p>",
      "special": false
    },
    {
      "id": "kes_on_omanik",
      "title": "Kes on soo omanik?",
      "subtitle": "Kui tegemist pole teist kellegi eramaaga, on vajalik välja selgitada, kes on kuivendatud sooala omanik",
      "info": "<p>Üldiselt kuuluvad Eestis suuremad sooalad riigile. Sellisel juhul vastutab nende hooldamise ja kasutamise eest Riigimetsa Majandamise Keskus (RMK). Kui maa asub kaitsealal, tuleb kindlasti suhelda ka Keskkonnaametiga, kes on kaitseala valitseja. Kui aga tegemist on eramaaga, tuleb rääkida otse maaomanikuga. Vahel võib juhtuda, et maad kasutab rentnik (näiteks turbakaevanduse firma), sel juhul tuleb rääkida nii omaniku kui ka kasutajaga ehk rentnikuga.</p>",
      "special": false
    },
    {
      "id": "mis_on_lugu",
      "title": "Mis on selle soo lugu?",
      "subtitle": "Uurige vanu kaarte, pilte ja lugusid, et teada saada, milline oli kodulähedane sooala vanasti",
      "info": "<p>Selleks, et mõista, mis toimub maastikul praegu, on vajalik tunda selle koha ajalugu. Aastakümnete jooksul on inimesed muutnud maastikke väga palju. Kaevatud on kraave, rajatud teid ja hooneid. Neid muutusi ei saa eirata, sest vahepeal toimunu on mõjutanud nii taimestikku, loomastikku, aga ka inimeste harjumusi ja ootusi.</p><p>Vastused tuleks leida sellistele küsimustele nagu:</p><ul><li>Millal ja kuhu kaevati kraavid?</li><li>Kus oli enne kuivenduskraave lage ala ja kus kasvasid puud?</li><li>Kus asusid taliteed või vanad rajad?</li><li>Kas ja kui jah, siis kus asuvad selles soos inimeste jaoks mingid olulised kohad (nt marjakohad, pelgupaigad vms)?</li></ul>",
      "special": false
    },
    {
      "id": "palju_raha",
      "title": "Palju on vaja raha?",
      "subtitle": "Koostage eelarve ja leidke taastamistööde jaoks rahastus",
      "info": "<p>Kui maaomanikult on taastamisplaanidele esialgne nõusolek olemas, saab liikuda edasi järgmise sammuga – otsida taastamistööde jaoks rahastust. Kõige kallimad on projekteerimis- ja ehitustööd soos, mis maksavad 100-1000 eurot hektari kohta, aga raha kulub ka uuringutele.</p><p>Tänapäeval toimub enamik soode taastamistöid projektipõhiselt, mis tähendab, et tuleb järgida kindlaid rahastusreegleid ja kinni pidada tähtaegadest.</p>",
      "special": false
    },
    {
      "id": "milline_praegu",
      "title": "Milline on ala praegu ja mis on plaan?",
      "subtitle": "Tellige esmased uuringud taastatava ala kohta, mille põhjal valmib taastamiskava",
      "info": "<p>Sageli küsitakse, kui kaugest ajast pärinevat maastikuilmet soovitakse taastada. Eesmärk ei olegi \"aega tagasi pöörata\". Taastamise lähtekohaks võetakse see, milline oli maastik vahetult enne inimesepoolset intensiivset sekkumist. Üldiselt peetakse silmas perioodi enne suuremahulisi kuivendustöid, mis Eestis toimusid alates 20. sajandi keskpaigast. Pärast seda muutus soomaastik kiiresti: kraave rajati palju ja sügavaid, mis mõjutas veetaset ja muutis sookooslused tundmatuseni.</p><p>Taastamise eesmärk on luua tingimused, et saaks taastuda looduslik soo. Selleks on vaja teha mitmeid eeluuringuid ja välitöid (nt käiakse läbi kõik kraavid, loendatakse liike, mõõdetakse veetaset, hinnatakse kooslusi tervikuna), mille tulemusena valmib esialgne taastamiskava.</p>",
      "special": false
    },
    {
      "id": "suhtlus",
      "title": "Pidev suhtlus",
      "subtitle": "Tehke koostööd ja suhelge huvigruppidega",
      "info": "<p><strong>Suhtlus</strong> toimub kogu taastamise protsessi jooksul. Otsuse, kas üldse taastada või mitte, peaks üldjuhul tegema maaomanik. Samas taastamistööde läbiviimise juures tuleb arvestada paljude huvigruppide esindajate kogemuse, teadmiste ning arvamusega. Inimeste kaasamiseks on palju erinevaid viise - alates küsitlusuuringutest, üks-ühele vestluste ja matkadeni, õppepäevadest talguteni, seminaridest veebihääletusteni.</p><p>Isegi kui kõik ei ole taastamise poolt, aitab rääkimine välja selgitada olulisi aspekte, näiteks millised kraavid, teed, kohad maastikul on inimestele eriliselt olulised ja mille kasutusmugavus peaks säilima.</p><p>Pane see kaart noolte peale, et rõhutada, milliste sammude vahel on suhtlus eriti oluline. Saad seda rakendada mitme noole puhul.</p>",
      "special": true
    },
    {
      "id": "arvuti_mudel",
      "title": "Kuidas võiks soo taastuda arvutis?",
      "subtitle": "Laske modelleerida, kuidas peaks vesi taastamisalal liikuma",
      "info": "<p>Tähtis on, et taastamisplaanid arvestaksid looduse ja inimeste vajadustega – ja seda saab arvutis vähemalt vee osas turvaliselt läbi mängida. Kõrgusmudelite abil saab näidata erinevate lahenduste mõju vee liikumisele ning plaanida taastamistööd võimalikult suure kasu ja väikese kahjuga. Lisaks kraavide täielikule sulgemisele saab ette näha ka veevoolu aeglustavaid lahendusi nagu ülevoolupaisud või sänge looduslikumaks kujundavad voolusuunajad kraavisängis.</p><p>Soo taastumiseks on parim veetase sutike alla maapinna ja sõltub sootüübist - lagesoodes on veetase kõrgemal kui soometsades. Väikesed veekogud võivad tekkida suletud kraavide ümbruses ja muudes suhteliselt madalamates kohtades.</p>",
      "special": false
    },
    {
      "id": "ehitusprojekt",
      "title": "Kuidas ehitada paise?",
      "subtitle": "Taastamiskava põhjal tellige töödele ehitusprojekt",
      "info": "<p>Kui peale pikemaid või lühemaid aruteluringe on taastamiskava valmis, teeb inseneribüroo omapoolsed uuringud ja koostab ehitusprojekti, kus on kirjas, kuidas peavad paisud olema ehitatud. Samuti on vaja nuputada, kuidas ja kuhu pääseb ligi kopaga, aga kuhu vaid jalgsi - neid paise ei saa rajada masinate abil, vaid näiteks talgute korras käsitsi. Kui ehitusprojekt on valmis, tuleb see uuesti kooskõlastada erinevate osapooltega ja välja kuulutada taastamistööde hange.</p>",
      "special": false
    },
    {
      "id": "teoks_tegemine",
      "title": "Kuidas teha plaanid teoks?",
      "subtitle": "Taastamistööde tegemine maastikul",
      "info": "<p>Põhiline taastamistegevus Eesti soodes on paisude rajamine kuivenduskraavidele, mida üldjuhul teevad sobivat tehnikat ja oskusi omavad firmad. Väiksemaid töid saab teha ka talgutena. Et masinad pääseksid õigetesse kohtadesse ligi, rajatakse neile liikumisteid e trasse, mille käigus võetakse maha nii vähe puid, kui võimalik.</p><p>Paisu ehitamine näeb üldiselt välja nagu hambaaugu parandus - esmalt puhastatakse kraavi põhi ja küljed mudast, taimedest ja nende juurtest ning ehitatakse ajutine veetõke, et paisu tegemise koht oleks ehitamise ajal korraks kuiv. Seejärel võtab kopp mitme meetri kauguselt turvast ning asetab kraavi põhja kuni pais on soovitud kõrgusega. Selleks, et vesi kraavi süvendist ümbritsevale maapinnale valgukspaisu ära ei viiks, tehakse paisule kraavi pervele tiivad - kraavile oleks justkui pandud plaaster. Kõige lõpus kaetakse pais mätastega.</p>",
      "special": false
    },
    {
      "id": "jarelevalve",
      "title": "Mis saab edasi?",
      "subtitle": "Järgnevate aastate jooksul jälgige, kuidas soo hakkab taastuma",
      "info": "<p>Mõne aasta jooksul kaovad maastikul taastamistööde jäljed ning ala võtab tasapisi soisema ilme. Uurimistööde käigus hinnatakse, kas soole iseloomulikud liigid on hakanud tagasi tulema, kuidas veetase aasta lõikes ühtlustub, kas vanadel turbakaevandusaladel kattub pinnas sootaimestikuga jpm.</p><p>Väike osa kuivendamise järgselt kasvama hakanud puudest võivad hukkuda, kuid toiteainete olemasolul tulevad asemele uued, kelle juurestik on kohanenud kõrge veetasemega. Osa metsa jääbki hõredam või tekivad ka lagedamad alad. Surnud puud pakuvad elupaika uutele liikidele, kes vajavadki lagupuitu. Ühtlasi väheneb üleujutuste oht, kuna soo hoiab ka sadudest tingitud liigvett paremini kinni. Tulekahju korral ei levi tuli märjas turbapinnases nii hõlpsasti. Taastuvat sood ja tema väärtusi saab näidata külalistele ja käia loomulikult nautimas eelkõige ise.</p>",
      "special": false
    }
  ],
  "correctOrders": [
    [
      "tahame_taastada",
      "kes_on_omanik",
      "mis_on_lugu",
      "palju_raha",
      "milline_praegu",
      "arvuti_mudel",
      "ehitusprojekt",
      "teoks_tegemine",
      "jarelevalve"
    ]
  ],
  "partialOrders": [
    {
      "order": [
        "tahame_taastada",
        "kes_on_omanik",
        "palju_raha",
        "mis_on_lugu",
        "milline_praegu",
        "arvuti_mudel",
        "ehitusprojekt",
        "teoks_tegemine",
        "jarelevalve"
      ],
      "feedback": "Kontrolli protsessi algust: enne rahastuse leidmist tuleks uurida soo ajalugu ja tausta."
    },
    {
      "order": [
        "tahame_taastada",
        "kes_on_omanik",
        "mis_on_lugu",
        "palju_raha",
        "milline_praegu",
        "ehitusprojekt",
        "arvuti_mudel",
        "teoks_tegemine",
        "jarelevalve"
      ],
      "feedback": "Arvutimudel peaks tulema enne ehitusprojekti koostamist, et planeerida parimaid lahendusi."
    },
    {
      "order": [
        "tahame_taastada",
        "kes_on_omanik",
        "mis_on_lugu",
        "milline_praegu",
        "palju_raha",
        "arvuti_mudel",
        "ehitusprojekt",
        "teoks_tegemine",
        "jarelevalve"
      ],
      "feedback": "Rahastust tuleks otsida enne uuringute tellimist, et olla kindel, et projektil on rahalist tuge."
    }
  ],
  "feedback": {
    "correct": "Õige! Oled kõik sammud paigutanud õigesse järjekorda.",
    "partial": "Järjekord on osaliselt õige. Mõned sammud on veel valesti.",
    "incorrect": "See järjekord ei ole õige. Palun proovi uuesti."
  }
};

  const cardsContainer = document.getElementById('cards-container');
  const placeholderColumn = document.getElementById('placeholder-column');
  const confirmBtn = document.getElementById('confirm-btn');

  const placeholders = Array.from(
    placeholderColumn.querySelectorAll('.placeholder-slot')
  );
  const arrows = Array.from(
    placeholderColumn.querySelectorAll('.arrow-indicator')
  );

  let state = {
    data: null,
    cards: new Map(),
    drag: null,
    inactivityTimer: null,
    inactivityGraceTimer: null,
    inactivityModalOpen: false,
    previouslyComplete: false
  };

  const infoModal = document.getElementById('info-modal');
  const confirmModal = document.getElementById('confirm-modal');
  const feedbackModal = document.getElementById('feedback-modal');
  const inactivityModal = document.getElementById('inactivity-modal');
  const resetModal = document.getElementById('reset-modal');

  const infoTitleEl = document.getElementById('info-modal-title');
  const infoSubtitleEl = document.getElementById('info-modal-subtitle');
  const infoBodyEl = document.getElementById('info-modal-body');
  const feedbackMessageEl = document.getElementById('feedback-message');

  document.getElementById('confirm-order').addEventListener('click', () => {
    closeModal(confirmModal);
    evaluateSequence();
  });

  document
    .getElementById('feedback-restart')
    .addEventListener('click', () => {
      closeModal(feedbackModal);
      resetGame();
    });

  document
    .getElementById('inactivity-continue')
    .addEventListener('click', () => {
      closeModal(inactivityModal);
      clearTimeout(state.inactivityGraceTimer);
      state.inactivityGraceTimer = null;
      state.inactivityModalOpen = false;
      resetInactivityTimer();
    });

  document.getElementById('inactivity-reset').addEventListener('click', () => {
    clearTimeout(state.inactivityGraceTimer);
    state.inactivityGraceTimer = null;
    closeModal(inactivityModal);
    state.inactivityModalOpen = false;
    resetGame();
  });

  document.getElementById('reset-btn').addEventListener('click', () => {
    openModal(resetModal);
  });

  document.getElementById('reset-confirm').addEventListener('click', () => {
    closeModal(resetModal);
    resetGame();
  });

  confirmBtn.addEventListener('click', () => {
    if (!confirmBtn.disabled) {
      openModal(confirmModal);
    }
  });

  document.querySelectorAll('[data-close]').forEach((btn) => {
    btn.addEventListener('click', (event) => {
      const id = event.currentTarget.getAttribute('data-close');
      const modal = document.getElementById(id);
      if (modal) {
        closeModal(modal);
      }
    });
  });

  document.addEventListener(
    'pointerdown',
    () => {
      registerActivity();
    },
    true
  );
  document.addEventListener(
    'keydown',
    () => {
      registerActivity();
    },
    true
  );

  console.log('Script loaded');
  console.log('gameData:', gameData);
  
  setupPlaceholders();
  initializeGame();

  function setupPlaceholders() {
    console.log('setupPlaceholders called, placeholders:', placeholders.length);
    placeholders.forEach((slot, index) => {
      slot.dataset.label = `${index + 1}. samm`;
      slot.dataset.cardId = '';
      slot.classList.add('empty');
    });
  }

  function initializeGame() {
    console.log('initializeGame called');
    state.data = gameData;
    createCards(gameData.elements);
    resetInactivityTimer();
  }

  function createCards(elements) {
    console.log('createCards called with', elements.length, 'elements');
    cardsContainer.innerHTML = '';
    state.cards.clear();

    // Scatter cards randomly, avoiding overlap
    const cardCount = elements.length;
    const padding = 24;
    const containerW = Math.max(cardsContainer.clientWidth, 600);
    const containerH = Math.max(cardsContainer.clientHeight, 520);
    const cardW = 180;
    const cardH = 110;
    const minDist = 40; // Minimum distance between card centers
    const placed = [];
    elements.forEach((element) => {
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.id = element.id;
      card.dataset.special = element.special ? 'true' : 'false';
      card.dataset.slotIndex = '';
      card.tabIndex = 0;

      if (element.special) {
        card.classList.add('special');
      }

      const title = document.createElement('div');
      title.className = 'card-title';
      title.textContent = element.title;
      card.appendChild(title);

      const subtitle = document.createElement('div');
      subtitle.className = 'card-subtitle';
      subtitle.textContent = element.subtitle;
      card.appendChild(subtitle);

      const infoIcon = document.createElement('img');
      infoIcon.src = 'assets/icons/info.svg';
      infoIcon.alt = 'More information';
      infoIcon.className = 'info-icon';
      card.appendChild(infoIcon);

      card.addEventListener('pointerdown', handlePointerDown);
      card.addEventListener('pointerup', handlePointerUp);
      card.addEventListener('pointercancel', handlePointerCancel);

      infoIcon.addEventListener('click', (event) => {
        event.stopPropagation();
        openInfoModal(element);
      });

      cardsContainer.appendChild(card);
      state.cards.set(element.id, {
        element,
        node: card
      });

      // Try random positions, avoid overlap
      let tries = 0;
      let left, top, ok;
      do {
        left = Math.random() * (containerW - cardW - 2 * padding) + padding;
        top = Math.random() * (containerH - cardH - 2 * padding) + padding;
        ok = placed.every(([x, y]) => {
          const dx = x - left;
          const dy = y - top;
          return Math.sqrt(dx * dx + dy * dy) > cardW - minDist;
        });
        tries++;
      } while (!ok && tries < 50);
      placed.push([left, top]);
      card.style.left = `${left}px`;
      card.style.top = `${top}px`;
      card.style.position = 'absolute';
      storePoolPosition(card);
    });
  }

  function positionCardRandomly(card, setHome = false) {
    const padding = 16;
    const maxLeft = Math.max(
      padding,
      cardsContainer.clientWidth - card.offsetWidth - padding
    );
    const maxTop = Math.max(
      padding,
      Math.max(cardsContainer.clientHeight, 520) - card.offsetHeight - padding
    );

    const left = Math.random() * (maxLeft - padding) + padding;
    const top = Math.random() * (maxTop - padding) + padding;

    card.style.left = `${left}px`;
    card.style.top = `${top}px`;
    card.style.position = 'absolute';

    if (setHome) {
      storePoolPosition(card);
    }
  }

  function handlePointerDown(event) {
    const card = event.currentTarget;
    const isInfo = event.target.classList.contains('info-icon');
    if (isInfo) {
      return;
    }

    event.preventDefault();
    registerActivity();

    if (isAnyModalOpen()) {
      return;
    }

  // Attempt pointer capture; not critical if it fails.
  try { card.setPointerCapture(event.pointerId); } catch (_) {}

    const originSlotIndex = card.dataset.slotIndex
      ? parseInt(card.dataset.slotIndex, 10)
      : null;

    // Record start rect BEFORE any DOM mutation so we can anchor to the visual origin
    const startRect = card.getBoundingClientRect();
    const offsetX = event.clientX - startRect.left;
    const offsetY = event.clientY - startRect.top;

    if (originSlotIndex !== null && !Number.isNaN(originSlotIndex)) {
      // Remove from slot after measuring so the rect doesn't collapse to 0,0
      removeCardFromSlot(card, originSlotIndex);
    }

    // Move card to body to ensure it's above everything, anchored at original pos
    card.style.position = 'fixed';
    card.style.left = `${startRect.left}px`;
    card.style.top = `${startRect.top}px`;
    card.style.margin = '0';
    // Let it take natural size first, then lock it to avoid reflow during drag
    card.style.width = '';
    card.style.height = '';
    document.body.appendChild(card);
    const naturalRect = card.getBoundingClientRect();
    card.style.width = `${naturalRect.width}px`;
    card.style.height = `${naturalRect.height}px`;

    card.classList.add('dragging');
    card.style.pointerEvents = 'none';

    state.drag = {
      card,
      offsetX,
      offsetY,
      originSlotIndex,
      lastHoverSlot: null,
      lastHoverArrow: null
    };

  document.addEventListener('pointermove', handlePointerMove, true);
  document.addEventListener('pointerup', handlePointerUp, true);
  document.addEventListener('pointercancel', handlePointerCancel, true);
  document.addEventListener('keydown', handleDragKeyDown, true);
  }

  function handlePointerMove(event) {
    if (!state.drag) return;
    const { card, offsetX, offsetY } = state.drag;

    const newLeft = event.clientX - offsetX;
    const newTop = event.clientY - offsetY;

    card.style.left = `${newLeft}px`;
    card.style.top = `${newTop}px`;

    highlightDropTarget(event.clientX, event.clientY, card);

    registerActivity();
  }

  function handlePointerUp(event) {
    if (!state.drag) return;
    const { card } = state.drag;
    try { card.releasePointerCapture(event.pointerId); } catch (_) {}
    document.removeEventListener('pointermove', handlePointerMove, true);
    document.removeEventListener('pointerup', handlePointerUp, true);
    document.removeEventListener('pointercancel', handlePointerCancel, true);
    document.removeEventListener('keydown', handleDragKeyDown, true);
    finalizeDrop(event.clientX, event.clientY);
  }

  function handlePointerCancel(event) {
    if (!state.drag) return;
    const { card, originSlotIndex } = state.drag;
    try { card.releasePointerCapture(event.pointerId); } catch (_) {}
    document.removeEventListener('pointermove', handlePointerMove, true);
    document.removeEventListener('pointerup', handlePointerUp, true);
    document.removeEventListener('pointercancel', handlePointerCancel, true);
    document.removeEventListener('keydown', handleDragKeyDown, true);

    card.classList.remove('dragging');
    card.style.pointerEvents = '';
    card.style.width = '';
    card.style.height = '';

    if (originSlotIndex !== null && Number.isInteger(originSlotIndex)) {
      placeCardInSlot(card, originSlotIndex);
    } else {
      snapToPoolPosition(card);
    }

    clearHoverHighlights();
    state.drag = null;
  }

  function handleDragKeyDown(e) {
    if (!state.drag) return;
    if (e.key === 'Escape') {
      // Synthesise a cancel
      handlePointerCancel({ pointerId: 0 });
    }
  }

  function returnCardToPool(card) {
    // Ensure card is moved to pool container with a random, non-overlapping position
    const padding = 24;
    const containerW = Math.max(cardsContainer.clientWidth, 600);
    const containerH = Math.max(cardsContainer.clientHeight, 520);
    const cardW = 180;
    const cardH = 110;
    const minDist = 40;
    
    // Get existing card positions in pool
    const placed = [];
    state.cards.forEach(({ node }) => {
      if (!node.dataset.slotIndex && node !== card) {
        const left = parseFloat(node.style.left || 0);
        const top = parseFloat(node.style.top || 0);
        placed.push([left, top]);
      }
    });
    
    // Find random position avoiding overlap
    let tries = 0;
    let left, top, ok;
    do {
      left = Math.random() * (containerW - cardW - 2 * padding) + padding;
      top = Math.random() * (containerH - cardH - 2 * padding) + padding;
      ok = placed.every(([x, y]) => {
        const dx = x - left;
        const dy = y - top;
        return Math.sqrt(dx * dx + dy * dy) > cardW - minDist;
      });
      tries++;
    } while (!ok && tries < 50);
    
    card.style.left = `${left}px`;
    card.style.top = `${top}px`;
    card.style.position = 'absolute';
    card.style.width = '';
    card.style.height = '';
    card.style.margin = '';
    card.dataset.slotIndex = '';
    card.dataset.poolLeft = String(left);
    card.dataset.poolTop = String(top);
    cardsContainer.appendChild(card);
  }

  function finalizeDrop(clientX, clientY) {
    const { card, originSlotIndex } = state.drag;
    const isSpecial = card.dataset.special === 'true';

    // Determine target at the moment of drop
    const path = document.elementsFromPoint(clientX, clientY);
    const slotTarget = path.find((el) => el.classList && el.classList.contains('placeholder-slot'));
    const arrowTarget = path.find((el) => el.classList && el.classList.contains('arrow-indicator'));
    // Do NOT clear positioning yet; we need the fixed rect for accurate pool placement.
    card.classList.remove('dragging');
    card.style.pointerEvents = '';

    let dropped = false;

    if (!isSpecial && slotTarget) {
      const targetIndex = parseInt(slotTarget.dataset.index, 10);
      if (Number.isInteger(targetIndex)) {
        const slotFilled = Boolean(slotTarget.dataset.cardId);
        if (slotFilled && originSlotIndex === null) {
          // From pool to filled slot: disallow, snap back
          snapToPoolPosition(card);
          dropped = true;
        } else if (slotFilled && originSlotIndex !== null) {
          const occupant = slotTarget.querySelector('.card');
          if (occupant) {
            slotTarget.removeChild(occupant);
            placeCardInSlot(card, targetIndex);
            placeCardInSlot(occupant, originSlotIndex);
            dropped = true;
          }
        } else {
          placeCardInSlot(card, targetIndex);
          dropped = true;
        }
      }
    } else if (isSpecial && arrowTarget && arrowTarget.classList.contains('active')) {
      arrowTarget.classList.add('comm');
      snapToPoolPosition(card);
      dropped = true;
    }

    if (!dropped) {
      // Check if drop happened inside the placeholder column
      const placeholderRect = placeholderColumn.getBoundingClientRect();
      if (
        clientX >= placeholderRect.left &&
        clientX <= placeholderRect.right &&
        clientY >= placeholderRect.top &&
        clientY <= placeholderRect.bottom
      ) {
        // Dropped in left column but not on valid slot/arrow - move to pool with random position
        returnCardToPool(card);
      } else {
        // Dropped elsewhere (pool or outside), snap to previous pool position
        storePoolPosition(card);
      }
    }

    // After the card has been placed (slot or pool), any inline drag sizing can be cleared.
    if (!card.dataset.slotIndex) {
      // Card ended in pool (absolute) -> sizing already normalized in helpers.
    } else {
      // In slot: ensure no stale drag dimensions remain.
      card.style.width = '';
      card.style.height = '';
      card.style.margin = '';
    }

    clearHoverHighlights();
    state.drag = null;
    checkCompletion();
  }

  function highlightDropTarget(clientX, clientY, card) {
    clearHoverHighlights();

    const path = document.elementsFromPoint(clientX, clientY);
    const slotTarget = path.find((el) =>
      el.classList && el.classList.contains('placeholder-slot')
    );
    const arrowTarget = path.find((el) =>
      el.classList && el.classList.contains('arrow-indicator')
    );

    if (card.dataset.special === 'true') {
      if (arrowTarget && arrowTarget.classList.contains('active')) {
        arrowTarget.classList.add('hover');
        state.drag.lastHoverArrow = arrowTarget;
      }
      return;
    }

    if (!slotTarget) return;
    const slotCardId = slotTarget.dataset.cardId;
    const isFromSlot = state.drag.originSlotIndex !== null;

    if (!slotCardId || isFromSlot) {
      slotTarget.classList.add('highlight');
      state.drag.lastHoverSlot = slotTarget;
    }
  }

  function clearHoverHighlights() {
    placeholders.forEach((slot) => slot.classList.remove('highlight'));
    arrows.forEach((arrow) => arrow.classList.remove('hover'));
    if (state.drag) {
      state.drag.lastHoverSlot = null;
      state.drag.lastHoverArrow = null;
    }
  }

  function placeCardInSlot(card, slotIndex) {
    const slot = placeholders[slotIndex];
    if (!slot) return;

    slot.classList.remove('empty', 'highlight');
    slot.classList.add('filled');
    slot.dataset.cardId = card.dataset.id;

    card.dataset.slotIndex = String(slotIndex);
    card.style.position = 'static';
    card.style.left = '';
    card.style.top = '';
    card.style.pointerEvents = '';

    slot.appendChild(card);
    updateArrows();
  }

  function removeCardFromSlot(card, slotIndex) {
    const slot = placeholders[slotIndex];
    if (!slot) return;

    if (slot.contains(card)) {
      slot.removeChild(card);
    }

    slot.dataset.cardId = '';
    slot.classList.add('empty');
    slot.classList.remove('filled');
    card.dataset.slotIndex = '';
    updateArrows();
  }

  function updateArrows() {
    arrows.forEach((arrow, index) => {
      const first = placeholders[index];
      const second = placeholders[index + 1];
      const active = first && second && first.dataset.cardId && second.dataset.cardId;

      if (active) {
        arrow.classList.add('active');
      } else {
        arrow.classList.remove('active');
        arrow.classList.remove('comm');
      }
    });
  }

  function snapToPoolPosition(card) {
    const poolLeft = parseFloat(card.dataset.poolLeft || '0');
    const poolTop = parseFloat(card.dataset.poolTop || '0');
    card.style.left = `${poolLeft}px`;
    card.style.top = `${poolTop}px`;
    card.style.position = 'absolute';
    card.style.width = '';
    card.style.height = '';
    card.style.margin = '';
    card.dataset.slotIndex = '';
    cardsContainer.appendChild(card);
  }

  function storePoolPosition(card) {
    // Compute position relative to the pool container
    const containerRect = cardsContainer.getBoundingClientRect();
    const cardRect = card.getBoundingClientRect();
    const relLeft = cardRect.left - containerRect.left + cardsContainer.scrollLeft;
    const relTop = cardRect.top - containerRect.top + cardsContainer.scrollTop;

    card.dataset.poolLeft = String(Math.max(0, relLeft));
    card.dataset.poolTop = String(Math.max(0, relTop));
    card.style.position = 'absolute';
    card.style.left = `${relLeft}px`;
    card.style.top = `${relTop}px`;
    card.style.width = '';
    card.style.height = '';
    card.style.margin = '';
    card.dataset.slotIndex = '';
    cardsContainer.appendChild(card);
  }

  function checkCompletion() {
    const allFilled = placeholders.every((slot) => slot.dataset.cardId);
    confirmBtn.disabled = !allFilled;

    if (allFilled && !state.previouslyComplete) {
      state.previouslyComplete = true;
      openModal(confirmModal);
    }

    if (!allFilled) {
      state.previouslyComplete = false;
    }
  }

  function evaluateSequence() {
    if (!state.data) return;
    const ids = placeholders.map((slot) => slot.dataset.cardId);
    const { correctOrders = [], partialOrders = [], feedback = {} } = state.data;

    let result = 'incorrect';
    let message = feedback.incorrect || 'That order is not correct. Please try again.';

    const isMatch = (arrA, arrB) =>
      arrA.length === arrB.length && arrA.every((value, index) => value === arrB[index]);

    const correctMatch = correctOrders.find((order) => isMatch(order, ids));
    if (correctMatch) {
      result = 'correct';
      message = feedback.correct || 'Correct! You have arranged all steps in the right order.';
    } else {
      const partialMatch = partialOrders.find((entry) => isMatch(entry.order, ids));
      if (partialMatch) {
        result = 'partial';
        message =
          partialMatch.feedback ||
          feedback.partial ||
          'The order is partially correct. Some steps are out of place.';
      }
    }

    feedbackMessageEl.textContent = message;
    openModal(feedbackModal);

    // Optional analytics payload placeholder
    if (navigator.onLine) {
      const payload = {
        timestamp: Date.now(),
        order: ids,
        result
      };

      // fetch('https://example.com/api/ordering-game', {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify(payload)
      // }).catch(() => {});
    }
  }

  function openInfoModal(element) {
    infoTitleEl.textContent = element.title;
    infoSubtitleEl.textContent = element.subtitle;
    infoBodyEl.innerHTML = element.info;
    openModal(infoModal);
  }

  function openModal(modal) {
    if (!modal) return;
    modal.setAttribute('aria-hidden', 'false');
    modal.style.display = 'flex';
    document.body.classList.add('modal-open');
    if (modal === inactivityModal) {
      state.inactivityModalOpen = true;
    }
  }

  function closeModal(modal) {
    if (!modal) return;
    modal.setAttribute('aria-hidden', 'true');
    modal.style.display = 'none';
    if (!isAnyModalOpen()) {
      document.body.classList.remove('modal-open');
    }
    if (modal === inactivityModal) {
      state.inactivityModalOpen = false;
    }
  }

  function isAnyModalOpen() {
    return (
      infoModal.getAttribute('aria-hidden') === 'false' ||
      confirmModal.getAttribute('aria-hidden') === 'false' ||
      feedbackModal.getAttribute('aria-hidden') === 'false' ||
      inactivityModal.getAttribute('aria-hidden') === 'false' ||
      resetModal.getAttribute('aria-hidden') === 'false'
    );
  }

  function resetGame() {
    closeModal(confirmModal);
    closeModal(feedbackModal);
    closeModal(inactivityModal);
    closeModal(resetModal);
    clearTimeout(state.inactivityGraceTimer);
    state.inactivityGraceTimer = null;

    placeholders.forEach((slot, index) => {
      const card = slot.querySelector('.card');
      if (card) {
        slot.removeChild(card);
        cardsContainer.appendChild(card);
        card.dataset.slotIndex = '';
      }
      slot.dataset.cardId = '';
      slot.classList.remove('filled');
      slot.classList.add('empty');
    });

    arrows.forEach((arrow) => {
      arrow.classList.remove('active', 'comm', 'hover');
    });

    // Scatter all cards randomly, avoiding overlap
    const cardCount = state.cards.size;
    const padding = 24;
    const containerW = Math.max(cardsContainer.clientWidth, 600);
    const containerH = Math.max(cardsContainer.clientHeight, 520);
    const cardW = 180;
    const cardH = 110;
    const minDist = 40;
    const placed = [];
    let i = 0;
    state.cards.forEach(({ node }) => {
      let tries = 0;
      let left, top, ok;
      do {
        left = Math.random() * (containerW - cardW - 2 * padding) + padding;
        top = Math.random() * (containerH - cardH - 2 * padding) + padding;
        ok = placed.every(([x, y]) => {
          const dx = x - left;
          const dy = y - top;
          return Math.sqrt(dx * dx + dy * dy) > cardW - minDist;
        });
        tries++;
      } while (!ok && tries < 50);
      placed.push([left, top]);
      node.style.left = `${left}px`;
      node.style.top = `${top}px`;
      node.style.position = 'absolute';
      storePoolPosition(node);
      i++;
    });

    confirmBtn.disabled = true;
    state.previouslyComplete = false;
    registerActivity();
  }

  function registerActivity() {
    resetInactivityTimer();
  }

  function resetInactivityTimer() {
    clearTimeout(state.inactivityTimer);
    if (state.inactivityModalOpen) return;
    state.inactivityTimer = setTimeout(() => {
      showInactivityModal();
    }, 60000);
  }

  function showInactivityModal() {
    state.inactivityTimer = null;
    openModal(inactivityModal);
    state.inactivityGraceTimer = setTimeout(() => {
      closeModal(inactivityModal);
      state.inactivityModalOpen = false;
      resetGame();
      state.inactivityGraceTimer = null;
    }, 10000);
  }
})();
